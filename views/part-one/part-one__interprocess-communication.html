<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="/css/style.css" />
  </head>
  <body>
    <header class="header">
      <nav>
        <ul class="part-list">
          <li>
            <a class="link-active" href="/part-one">Processes & Threads</a>
          </li>
          <li><a href="/part-two">Memory Management</a></li>
          <li><a href="/part-three">File Systems</a></li>
          <li><a href="/part-four">Input/Output</a></li>
          <li><a href="/part-five">Deadlocks</a></li>
          <li><a href="/part-six">Virtualization & Cloud</a></li>
          <li><a href="/part-seven">Multi CPU System</a></li>
        </ul>
      </nav>
    </header>

    <article class="main">
      <h2>Processes & Threads</h2>

      <ul class="blog-list">
        <li>
          <a href="/part-one/processes">Processes</a>
        </li>
        <li>
          <a href="/part-one/threads">Threads</a>
        </li>
        <li>
          <a class="link-active" href="/part-one/interprocess-communication"
            >Interprocess Communication</a
          >
        </li>
        <li>
          <a href="/part-one/scheduling">Scheduling</a>
        </li>
      </ul>

      <h3>Interprocess Communication</h3>
      <p>
        Processes frequently need to communicate with other processes. For
        example, in a shell pipeline, the output of the first process must be
        passed to the second process, and so on down the line. Thus there is a
        need for communication between processes, preferably in a
        well-structured way not using interrupts
      </p>

      <p>
        Very briefly, there are three issues here. The first was alluded to
        above: how one process can pass information to another. The second has
        to do with making sure two or more processes do not get in each otherâ€™s
        way, for example, two processes in an airline reservation system each
        trying to grab the last seat on a plane for a different customer. The
        third concerns proper sequencing when dependencies are present: if
        process A produces data and process B prints them, B has to wait until A
        has produced some data before starting to print.
      </p>

      <h4>Race Conditions</h4>
      <p>
        In some operating systems, processes that are working together may share
        some common storage that each one can read and write. The shared storage
        may be in main memory (possibly in a kernel data structure) or it may be
        a shared file; the location of the shared memory does not change the
        nature of the communication or the problems that arise.
      </p>
      <p>
        Situations where two or more processes are reading or writing some
        shared data and the final result depends on who runs precisely when, are
        called race conditions.
      </p>
      <p>
        How do we avoid race conditions? The key to preventing trouble here and
        in many other situations involving shared memory, shared files, and
        shared everything else is to find some way to prohibit more than one
        process from reading and writing the shared data at the same time.
      </p>
      <p>
        Put in other words, what we need is <strong>mutual exclusion</strong>,
        that is, some way of making sure that if one process is using a shared
        variable or file, the other processes will be excluded from doing the
        same thing.
      </p>
      <p>
        The problem of avoiding race conditions can also be formulated in an
        abstract way. Part of the time, a process is busy doing internal
        computations and other things that do not lead to race conditions.
        However, sometimes a process has to access shared memory or files, or do
        other critical things that can lead to races. That part of the program
        where the shared memory is accessed is called the
        <strong>critical region</strong> or <strong>critical section</strong>.
        If we could arrange matters such that no two processes were ever in
        their critical regions at the same time, we could avoid races.
      </p>

      <p>
        Although this requirement avoids race conditions, it is not sufficient
        for having parallel processes cooperate correctly and efficiently using
        shared data. We need four conditions to hold to have a good solution:
      </p>
      <ol>
        <li>
          No two processes may be simultaneously inside their critical regions.
        </li>
        <li>No assumptions may be made about speeds or the number of CPUs.</li>
        <li>
          No process running outside its critical region may block any process.
        </li>
        <li>
          No process should have to wait forever to enter its critical region.
        </li>
      </ol>

      <a class="end-link" href="/part-one/scheduling"
        >Next chapter: Scheduling</a
      >
    </article>
  </body>
</html>
